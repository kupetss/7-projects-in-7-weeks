# 7 проектов за 7 недель

### 1 неделя: Утилита командной строки
Консольный подсчетчик строк (аналог wc -l), но с флагами
Умеет принимать флаг -file или просто путь как аргумент
Если передана директория, рекурсивно считает строки во всех файлах
Выводит красивую табличку в консоль
Подсчет строк, слов и байт (флаги -l, -w, -c).

### 2 неделя: HTTP REST API сервер
Простой API для хранения задач (Todo List), но с "изюминкой" — хранение в памяти + автоматическое логирование в JSON-файл (бэкап)
Эндпоинты:
POST /task — создать задачу.
GET /tasks — получить все задачи.
PATCH /task/:id — переключить статус (выполнено/не выполнено).
GET /log — отдает JSON-файл с логами действий (кто и когда создал задачу).

### Неделя 3: Конкурентность и горутины
Быстрый консольный паук, который обходит сайт и собирает все ссылки
Пользователь вводит URL
Программа качает HTML
Находит там все ссылки
Рекурсивно обходит найденные ссылки
Используем горутины: на каждую найденную страницу запускаем отдельную горутину для скачивания
Используем каналы: чтобы собирать результаты и ограничивать количество одновременных запросов (чтобы не заблокировать сайт, используем буферизированный канал как семафор)

### Неделя 4: Работа с базами данных и миграции
Тот же API с Задачами (Todo), но теперь с PostgreSQL и миграциями
Пишем миграции создать таблицу users и tasks
Добавляем регистрацию и JWT-авторизацию
Теперь задачи привязаны к конкретному пользователю
Все взаимодействия — через базу данных
И docker-compose.yml, который поднимает Go-приложение и PostgreSQL

### Неделя 5: Микросервисы и gRPC
Два микросервиса, общающихся по gRPC
Сервис А (Калькулятор): Принимает gRPC запросы и возвращает результат
Сервис Б (API Gateway):
Имеет HTTP REST API (как на 2-й неделе)
Когда пользователь шлет POST /calculate, Gateway конвертирует JSON в gRPC протобуф, шлет запрос в Сервис А, получает ответ и отдает пользователю обратно в JSON

### Неделя 6: Очереди и асинхронная обработка (RabbitMQ / Kafka)
Система обработки заказов
Продюсер (HTTP сервер)
Приходит запрос POST /order — кладем задачу в очередь RabbitMQ и сразу отвечаем пользователю: "Заказ принят в обработку"
Пишем консьюмер. Он висит и слушает очередь. Как только приходит сообщение, он начинает его "обрабатывать"
(просто спит 5 секунд, имитируя работу, и пишет в лог "Заказ 123 обработан")
Добавляем подтверждения, чтобы при падении воркера задача не потерялась

### Неделя 7: Финальный аккорд — полезный бот
Telegram бот для учета личных финансов
Пользователь пишет: +500 кофе или -150 автобус
Бот сохраняет это в базу данных (SQLite или Postgres)
Умеет показывать статистику за день/неделю: /stats
Каждый вечер бот присылает пользователю итог дня
Заворачиваем всё в Docker